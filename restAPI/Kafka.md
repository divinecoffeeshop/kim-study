# 카프카(KAFKA)

## 카프카(KAFKA)란?
- 카프카(Kafka)는 파이프라인, 스트리밍 분석, 데이터 통합 및 미션 크리티컬 애플리케이션을 위해 설계된 고성능 분산 이벤트 스트리밍 플랫폼이다.
- Pub-Sub 모델의 메시지 큐 형태로 동작하며 분산환경에 특화되어 있다.  
- Pub-Sub 모델 -> 발행-구독: 비동기 메시지 전달을 위한 소프트웨어 아키텍처 패턴의 하나

## 카프카의 탄생 배경
LinkedIn에서 개발된 pub-sub 모델의 메시지큐 방식 기반, 분산 메시징 시스템이다.
### 기존 데이터 시스템의 문제점
각 애플리케이션과 DB가 end-to-end 로 연결되어 있고(각 파이프라인이 파편화 되어있음), 요구사항이 늘어남에 따라 데이터 시스템 복잡도가 높아지면서 문제가 발생.

1. **시스템 복잡도 증가**
- 통합된 전송 영역이 없어 데이터 흐름을 파악하기 어렵고, 시스템 관리가 어려움
- 특정 부분에서 장애 발생 시 조치 시간 증가 (연결 되어있는 애플리케이션들을 모두 확인해야 하기 때문에)
- HW 교체 / SW 업그레이드 시 관리포인트가 늘어나고, 작업시간 증가 (연결된 애플리케이션에 side effect 가 없는지 확인해야 함)

2. **데이터 파이프라인 관리의 어려움**
- 각 애플리케이션과 데이터 시스템 간의 별도의 파이프라인 존재하고, 파이프라인 마다 데이터 포맷과 처리 방식이 다름
- 새로운 파이프라인 확장이 어려워지면서, 확장성 및 유연성이 떨어짐
- 데이터 불일치 가능성이 있어 신뢰도 감소

### 카프카 적용 후
- 모든 이벤트/데이터의 흐름을 중앙에서 관리할 수 있게 됨
- 새로운 서비스/시스템이 추가되도 카프카가 제공하는 표준 포맷으로 연결하면 되므로 확장성과 신뢰성이 증가
- 개발자는 각 서비스간의 연결이 아닌, 서비스들의 비즈니스 로직에 집중 가능

## 카프카의 동작 방식 및 특징
**카프카의 구성요소**
***Topic***
- 각각의 메시지를 목적에 맞게 구분할 때 사용한다.
- 메시지를 전송하거나 소비할 때 Topic을 반드시 입력한다.
- Consumer는 자신이 담당하는 Topic의 메시지를 처리한다.
- 한 개의 토픽은 한 개 이상의 파티션으로 구성된다.
***Partition***
- 분산 처리를 위해 사용된다.
- Topic 생성 시 partition 개수를 지정할 수 있다. (파티션 개수 변경 가능. *추가만 가능)
- 파티션이 1개라면 모든 메시지에 대해 순서가 보장된다.
- 파티션 내부에서 각 메시지는 offset(고유 번호)로 구분된다.
- 파티션이 여러개라면 Kafka 클러스터가 라운드 로빈 방식으로 분배해서 분산처리되기 때문에 순서 보장 X
- 파티션이 많을 수록 처리량이 좋지만 장애 복구 시간이 늘어난다.
***Offset***
- Consumer에서 메세지를 어디까지 읽었는지 저장하는 값
- Consumer 그룹의 컨슈머들은 각각의 파티션에 자신이 가져간 메시지의 위치 정보(offset) 을 기록
- Consumer 장애 발생 후 다시 살아나도, 전에 마지막으로 읽었던 위치에서부터 다시 읽어들일 수 있다.
***Producer***
- 메시지를 만들어서 Kafka 클러스터에 전송한다.
- 메시지 전송 시 Batch 처리가 가능하다.
- key값을 지정하여 특정 파티션으로만 전송이 가능하다.
- 전송 acks값을 설정하여 효율성을 높일 수 있다.
- **ACKS=0** -> 매우 빠르게 전송. 파티션 리더가 받았는 지 알 수 없다.
- **ACKS=1** -> 파티션 리더가 받았는지 확인. 기본값
- **ACKS=ALL** -> 파티션 리더 뿐만 아니라 팔로워까지 메시지를 받았는 지 확인
***Consumer***
- Kafka 클러스터에서 메시지를 읽어서 처리한다.
- 메세지를 Batch 처리할 수 있다.
- 한 개의 Consumer는 여러 개의 토픽을 처리할 수 있다.
- 메시지를 소비하여도 메시지를 삭제하지는 않는다. (Kafka delete policy에 의해 삭제)
- 한 번 저장된 메시지를 여러번 소비도 가능하다.
- Consumer는 Consumer 그룹에 속한다.
- 한 개 파티션은 같은 Consumer그룹의 여러 개의  Consumer에서 연결할 수 없다
***Broker***
- 실행된 Kafka 서버를 말한다.
- 프로듀서와 컨슈머는 별도의 애플리케이션으로 구성되는 반면, 브로커는 Kafka 자체이다.
- Broker(각 서버)는 Kafka Cluster 내부에 존재한다.
- 서버 내부에 메시지를 저장하고 관리하는 역할을 수행한다.
***Zookeeper***
- 분산 애플리케이션 관리를 위한 코디네이션 시스템
- 분산 메시지큐의 메타 정보를 중앙에서 관리하는 역할
**동작 원리**
1. publisher는 전달하고자 하는 메세지를 topic을 통해 카테고리화 한다.
2. subscriber는 원하는 topic을 구독(=subscribe)함으로써 메시지를 읽어온다.
3. publisher와 subscriber는 오로지 topic 정보만 알 뿐, 서로에 대해 알지 못한다.
4. kafka는 broker들이 하나의 클러스터로 구성되어 동작하도록 설계
5. 클러스터 내, broker에 대한 분산처리는 ZooKeeper가 담당한다.
**메시지 큐**
메시지 큐는 메시지 지향 미들웨어(MOM : Message Oriented Middleware)를 구현한 시스템으로 프로그램(프로세스) 간의 데이터를 교환할 때 사용하는 기술이다.
Producer - Messege Queue(Broker) - Consumer
1. producer: 정보를 제공하는 자
2. consumer: 정보를 제공받아서 사용하려는 자
3. Queue: producer의 데이터를 임시 저장 및 consumer에 제공하는 곳

***메시지 큐의 장점***
1. 비동기: queue라는 임시 저장소가 있기 때문에 나중에 처리 가능
2. 낮은 결합도: 애플리케이션과 분리
3. 확장성: producer or consumer 서비스를 원하는대로 확장할 수 있음
4. 탄력성: consumer 서비스가 다운되더라도 애플리케이션이 중단되는 것은 아니며 메시지는 지속하여 MQ에 남아있다.
5. 보장성: MQ에 들어간다면 결국 모든 메시지가 consumer 서비스에게 전달된다는 보장을 제공한다.

**메시지 브로커/이벤트 브로커**
***메시지 브로커***
- **Publisher**가 생산한 메세지를 메세지 큐에 저장하고, 저장된 데이터를 **Consumer**가 가져갈 수 있도록 중간 다리 역할을 한다. 
- 보통 서로 다른 시스템(혹은 소프트웨어) 사이에서 데이터를 비동기 형태로 처리하기 위해 사용한다.
- 이와 같은 메세지 브로커들은 consumer가 큐에서 데이터를 가져가게 되면 즉시 혹은 짧은 시간 내에 큐에서 데이터가 삭제되는 특징들이 있다.
- 대표적으로는 Redis, RabbitMQ 소프트웨어가 있고, GCP의 pubsub, AWS의 SQS 같은 서비스가 있다.

***이벤트 브로커***
- 이벤트 브로커 또한 기본적으로 메세지 브로커의 큐 기능들을 가지고 있어 메세지 브로커의 역할도 할 수 있다.
- 메시지 브로커와의 차이점: 이벤트 브로커는 **publisher**가 생산한 이벤트를 이벤트 처리 후에 바로 삭제하지 않고 저장하여, 이벤트 시점이 저장되어 있어서 **consumer**가 특정 시점부터 이벤트를 다시 **consume** 할 수 있는 장점이 있다. 또한 대용량 처리에 있어서는 메세지 브로커보다는 더 많은 양의 데이터를 처리할 수 있는 능력이 있다. 
- 대표적으로는 Kafka, AWS의 kinesis 같은 서비스가 있다.

## 메시징 시스템 비교
| 항목 | Kafka | RabbitMQ | Redis Pub/Sub |
|------|-------|-----------|----------------|
| **라우팅** | 기본 기능으로는 라우팅을 지원하지 않음<br>Kafka Streams를 활용하여 동적 라우팅 구현 가능 | Direct, Fanout, Topic, Headers 라우팅 옵션 제공으로 유연한 라우팅 가능 | - |
| **프로토콜** | TCP 기반 커스텀 프로토콜 (단순한 메시지 헤더 사용)<br>→ 대체 어려움 | AMQP, MQTT, STOMP 등 다양한 메시징 프로토콜 지원 | RESP (Redis Serialization Protocol)<br>TCP 통신 |
| **우선순위 처리** | 변경 불가능한 시퀀스 큐<br>→ 파티션 내 시간 순서는 보장하지만, 여러 파티션 병렬 처리 시 시간 순서 보장 어려움 | Priority Queue 지원<br>→ 우선 순위에 따라 처리 가능 | 우선순위 처리 불가<br>→ 이벤트 도착 여부조차 보장되지 않음 |
| **이벤트 저장 (Durability)** | 이벤트를 삭제하지 않고 디스크에 저장<br>→ 영속성 보장 및 재처리 가능 | 메시지가 성공적으로 전달된 경우 큐에서 삭제<br>→ 재처리 어려움 | 저장하지 않음<br>→ Subscriber가 없으면 이벤트 소실 |
| **장점** | - 이벤트 영속성 보장<br>- 고성능, 고가용성, 분산 처리에 적합<br>- Producer 중심 구조로 대량 데이터 병렬 처리 유리 | - 오래된 기술로 제품 성숙도 높음<br>- 동기/비동기 처리 모두 가능<br>- 유연한 라우팅과 메시지 전달 보장<br>- 기본 UI 제공 | - Subscriber 모두에게 이벤트 전송됨<br>→ Kafka보다 동기화 이슈 적음<br>- 미들웨어 불필요해 가볍고 간단 |
| **단점** | - 범용 메시징 시스템이 제공하는 다양한 기능 부족 | - Kafka에 비해 느림 | - 이벤트 도착조차 보장되지 않음<br>- 메시지 손실 가능성 있음 |
